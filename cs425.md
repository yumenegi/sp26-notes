# CS 425
## 01/21/25
### Overview
- What is a distributed system?
  - Hardware and software components located at networked computers that communicate or coordinate through passing messages
  - A collection of computing elements connected by a network
  - Independent components connected by network and passing messages to achieve a common goal as a single system
- Cascading failures
  - Failure in another computer of the distributed system can render the user's own computer unusable
- Why distributed systems
    - Scalability
    - Compute
    - Reliability/fault tolerance
    - Conquier geographic separation
    - Customize computers for speicifc tasks
### Scaling Example
- One server running both webserver and DB
- Two servers
  - One for server and one for db
  - System is offline twice as often
- Scalable number of front-end web server
  - Stateless
    - If a server crash, can reconnect user to another server
    - Use various policies to map users to front-ends
- Scalable number of dbs
  - Distributed systems code
  - Remains usable even with crash

### Challenges
- **Concurrent execution**
- **Independent failure**
- Autonomous administrationz

### Networked Communications
- **Async**
- **Unreliable**
- Insecure

### Common Goals
- **Consistency**
- Transparency

### How Processes Communicate
- Directly using network sockets
- Subscriber/Publisher
- Distributed share memory
- Differ with the nature of the system

### Communication Channel properties
- Latency (L): Total amount of time between the start of the message transmission to the receiving of the first bit of the message
- Bandwidth (B): Total amount of infromation that can be transmitted over the channel per unit time
  - Total time taken to pass a message is governed by latency and bandwidth of the channel

### Syncronous Distributed Systems
- Known upper and lower bounds on time taken by each step in a process
- Known bounds on messsage passing delays
- Known bounds on clock drift

### Asynchronous
- No bounds on execution speeds
- No bounds on message delay
- No bounds on clock drift

### Real Life Systems
- Most are asynchronous

### Detect a crashed process
- Health check pings
  - Time-outs would imply a crashed process
- Periodic
  - Heartbeats
  - If no heartbeats, dead process

### Periodic Ping
- $\Delta _1$ is the timeout value, host sends pings to slave every $T$ seconds
- If $\Delta _1$ is exceeded and no ack from slave, report crash
  - If synchronous, $\Delta _1 = 2 (\text{max delay})$ 
  - If asynchronous $\Delta _1 = k(\text{max observed round trip time})$
    - $k > 1$ is a reasonable estimate

### Heartbeats
- Slave sends heartbeats to host every $T$ seconds
- $(T+\Delta _2)$ is the timeout value at host
- If $(T+\Delta _2)$ time elapsed since last heartbeat, report slave crashed
- If synchrnous, $\Delta _2 = maxD - minD$, $D=delay$
  - Worst case heartbeat gap of synchronous system can be calculated by taking $t+minD$, the best case receiving time of the first heartbeat at the host, subtracted by $t+T+maxD$, the worst case receiving time of the second heartbeat at the host, where $t$ is the arbitrary time at which the heartbeat is sent
- If async, $\Delta _2 = \text{observed delay}$

### Correctness of Failure Detection
- Characterized by completeness and accuracy
- Completeness
  - Every fail is logged
- Accuracy
  - All detection correspond to actual failed process
- Synchrnous
  - Failure detection via ping-ack and heartbeat is both complete and accurate
- Asynchronous
  - Impossible to achieve both completeness and accuracy
  - Our strategy for ping-ack and heartbeat is complete

### Metric for failure detection
  - Worst case failure detection time
  - **Ping-ack**
    - $T+\Delta _1 - \Delta$ where $\Delta$ is the time taken for the last ping from master to reach slave before slave crashed. $T$ is the time period for pings
    - $t$
      - Master pings
    - $t+\Delta$
      - Slave responds and fails immediately
    - $t+T$
      - Master pings again
    - $t+T+\Delta _1$
      - Time-out and crash detected
    - The system crashes at $t+\Delta$ and the crash is detected at $t+T+\Delta _1$
  - **Heartbeat**
    - $T+\Delta _2 + \Delta$
    - $T+2\times max - min$
    - $t$
      - Slave sends heartbeat and fails immediately
    - $t+\Delta$
      - Master receives heartbeat
    - $t+\Delta+\Delta _1$
      - Master did not receive heartbeat, crash detected
    - Worst case of value $\Delta$ is max network delay and $Delta _1$ is $max-min$
  - Bandwidth
    - Ping-ack
      - 2 messages every $T$
    - Heartbeat 
      - 1 message evert $T$
    - Decreasubg $T$ leads to faster detection but more bandwidth usage
  - Effect of increase $\Delta _1$ and $\Delta _2$
    - Increase accuracy if asynchronous system
    - Leads to longer detection time

### Type of Failure
- **Omission**
  - When a process or a channel fails to perform an action
  - Channel Omission: omitted by channel
  - Send omission: process completes ‘send’ operation, but message does not reach its outgoing message buffer.
  - Receive omission: message reaches the incoming message buffer, but not received by the process. 

## 01/28/26
- Key Aspects
  - Variable communication time
  - Failure to communicate
  - Different clocks
- Two ways to model
  - Synchronous distributed system
    - Known upper and lower bounds on time taken by each step
    - Known bounds on passing delays
    - Known bounds on clock drift rates
  - Async systems
    - No bounds on execution speeds, passing delays, clock drifts

### Omission
  - When a process or channel fails to perform its action
    - Process may crash
      - Detected using ping ack or heartbeats
      - Completeness and accuracy in synch and asynch systems
      - Worst case failure detection time
    - Fail-stop: if other process can certainly detect the crash
    - Communication omission: when message get dropped

### Two Generals Problem
- Two generals send messenger, attack at dawn, don't know if the other general received the message
- Keep sending message until an acknowledgement arrives
  - When message stops, the confirmation have reached the other
- Good enough
- Message drops can be mitigated by network protocols

### Arbitrary/Byzantine Failures
- Any type of error, e.g. a process executing incorrectly, sending a wrong message etc
  - Hard to detect
- Causes
  - Malicious entity
  - Bugs

### Timing Failures
- Timing guarantees are not met
  - Only in synchrioous systems

### Centralized Heartbeats
- Extending to multiple processes instead of just two
- Centralized Heartbeating
  - All processes send to centralized $p_i$
    - What if $p_i$ crashes?

### Ring Heartbeating
- $p_i$ to $p_j$
- If two nodes next to each other fail, we don't know all the nodes that failed
- Ring repair overhead when failed process detected

### All-to All Heartbeats
- Everyone can keep track of everyone
- Downside is clogging communication pathways
- Can reduce overhead by sending to ranodmly selected processes

### Clocks
- Importance
  - Performance metrics
    - Requires computer's clock to be synchrnized
    - Cannot measure one way delay, no perfectly synced clock, but can locally calculate time of sent and receiving
  - Timestamps to order events in system
    - Semantic reasons
    - Debugging
    - Logging
  - Require accurate clocks for synchrnized global authority for payment
- Clock Slew and Drift rates
  - Each process has an internal clock
  - Clock skew is relative different between two clock values
  - Clock drift rate is change in skew from a perfect reference clock per unit time as measured by the reference
    - Depends on change in the frequency of oscillation of a crystal
- Synchrnous systems have bound on maximum drift rate
- Ordinary quartz clock drifts $10^{-6}$ seconds
  - Drift by 1 seconds every 11.6 days
  - Skew of about 30 minutes after 60 years
- High precision atomic clocks
  - Drift rate of $10^{-13}$ seconds/second
  - UTC (universal coordinated time) is from that clock

### Clock Synchronization
- External Synchronization
  - Synchronize time with an authoritative clock
  - When accurate timestamps are required
- Internal Synchronization
  - If you know your own drift rate, you can account for that
  - Synchronize time internally between all processes in a distributed system
  - When internally comparable timestamps are required

### Synchronization Bound
- Synchronization bound (D) between two clocks A and B over a real time interval I
  - |A-B| < D for all t in the real time interval I
    - Difference in time
    - Skew(A,B) < D during the time interval I
    - A and B agree within a bound D
  - If A is authoritative, D can also be called accuracy bound
    - B is accurate within a bound of D
- Synchronization/Accuracy bound at time t with worst case skew between two clocks at time t is less than D
- For externally sync'd system, largest bound within a system is 2*D

### Synchronization in Synchronous Systems
- Client: what is the time
- Server: It is $T_s$
- What time does client set its local clock to
- There is delay with server time check
  - $T_c = T_s+\Delta$
  - $\Delta$ is expected message delay
  - Server sends message at $T_s$ time
  - We don't know the value of message delay $\Delta$
- Worst case after sync
  - If we assume the following situations
  - $T_c=T_s, skew(client, server) \leq max \Delta$
  - $T_c = (T_s + max), skew(client, server) \leq max-min$
  - $T_c = (T_s + min), skew(client,server) \leq max-min$
  - $T_c = (T_s + (min+max)/2), skew(client,server) \leq (max-min)/2$

### Asynchronous Time Synchronization 
- Cristian Algorithm
- Berkeley Algorithm
- NTP (Network Time Protocol)

### Cristian Algorithm
- Client: what is the time
- Server: It is $T_s$
- Receives message at $T_s + \Delta$
- We don't know the delta, but we can measure round trip time ($T_{round}$)
- $T_c = T_s + (T_{round} / 2)$
- $skew \leq (T_{round} / 2) - min$ or if we don't know min it's zero
  - Worst case, one of them take min time
- We can improve accuracy by sending multiple requests and using response with the smallest Tround
- In case of server failure, we use multiple time servers

### Berkely Algorithm
- Only for internal synchronization
- More rubustness
- Especially when dealing with faulty clocks
- Server periodically polls clients about local time
- Each client responds with local time
- Server uses Cristian to estimate the local at each client
- Average all local times including its own to use it as updated time
- Send the offset to each clock since it already knows their local time
- Handling faulty processes by only using timestamps within some threshold of each other
- Handling server failure by detect the failure and electing a new leader

### NTP
- Time service over the internet for synchronizing to UTC
- Hierarchy
  - Primary clocks that syncs with UTC
  - Secondary sync'd with primary
  - Strata 3, sync'd with secondary
- Hierarchical structure for scalability
- Lower strata servers for robustness
- How are the synchronized?
  - Servers may multicast timestamps within a LAN, Clients adjust time assuming a small delay. Low ccuracy
  - Procedure-call, higher accuracy; Cristian algorithm on lower stratas
  - Symmetric mode synchronization lower strata servers, highest accuracy

### NTP Symmetric Synchronization
- A and B exchange messages and record the send and receive timestamps
  - A sends message at $T_{As}$ and B receives at $T_{Br}$
  - B sends message at $T_{Bs}$ and a receives at $T_{Ar}$
  - A and B exchange their local timestamps
- Use these timestamps to compute offset with respect to one another
  - t and t' are actual transmission times for m and m' which are unknown transmission times
  - o is true offset at B relative to clock A
  - o_i is the estimate of actual offset between the two clocks
  - $T_{Br} = T_{As} + t + o$
  - $T_{Ar} = T_{Bs} + t' - o$
  - $o=((T_{Br} - T_{As})-(T_{Ar} - T_{Bs})+(t'-t))/2$
  - $o_i=((T_{Br} - T_{As})-(T_{Ar} - T_{Bs}))/2$
    - We assume $t'$ and $t$ are equal
  - $o=o_i+(t'-t)/2$
    - We know $d_i=t+t'$ and we use it as worst case
      - If one of them is close to zero in the worst case $t+t'$ will be close to $t-t'$ or $t'-t$
    - $d_i$ is synchronization bound

## 01/30/26
### Logical Clocks and Time Stamps
#### Event Ordering
- Why order events using clock and time stamps
  - Debugging and analysis
  - Reconciling updates made to an object in a distributed datastore
  - Rollback recovery during fa